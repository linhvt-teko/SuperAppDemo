// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3 (swiftlang-1200.0.29.2 clang-1200.0.30.1)
// swift-module-flags: -target armv7-apple-ios10.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name Minerva
import CommonCrypto
import CommonCrypto/*.CC_LONG*/
import CommonCrypto/*.CC_MD5*/
import CommonCrypto/*.CC_MD5_DIGEST_LENGTH*/
import FirebaseCore
import FirebaseFirestore
import Foundation
import Kingfisher
@_exported import Minerva
import SVProgressHUD
import SnapKit
import Swift
import SwiftyJSON
import TekCoreNetwork
import TekCoreService
import TerraInstancesManager
import Toast_Swift
import UIKit
public enum PaymentError : Foundation.LocalizedError {
  case timeOut
  case missingPaymentConfig
  case service(error: Minerva.PaymentError.ServiceError)
  case observe(error: Minerva.PaymentObserveError)
  case register(error: Minerva.MethodRegisterError)
  case unexpected
  case cancel
  public enum ServiceError : Foundation.LocalizedError {
    case invalidChecksum
    case invalidData
    case invalidOrder
    case invalidTransaction
    case failedTransaction
    case suspiciousTransaction
    case cancelledByCustomer
    case other
    public init(code: Swift.Int)
    public static func == (a: Minerva.PaymentError.ServiceError, b: Minerva.PaymentError.ServiceError) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
public protocol IMethodRegisterResultInfo {
  var type: Minerva.PaymentMethodType { get }
  var terminal: Swift.String { get }
  var message: Swift.String? { get }
  var error: Minerva.MethodRegisterError? { get }
  var isSuccess: Swift.Bool { get }
}
public protocol IMethodsRegisterResult {
  var success: [Minerva.IMethodRegisterResultInfo] { get }
  var failure: [Minerva.IMethodRegisterResultInfo] { get }
  var message: Swift.String? { get }
  var error: Minerva.PaymentError? { get }
}
public enum IMethodRegisterResult {
  case success
  case failure(error: Minerva.PaymentError, msg: Swift.String?)
}
extension IMethodsRegisterResult {
  public func getInfo(method: Minerva.PaymentMethodType) -> Minerva.IMethodRegisterResult
}
public class SecretKey {
  public init(rawValue: [Swift.String : Any])
  @objc deinit
}
public class MerchantConfig {
  public init(rawValue: [Swift.String : Any])
  public init(code: Swift.String, terminalCode: Swift.String)
  @objc deinit
}
public class PaymentServiceConfig {
  public init(rawValue: [Swift.String : Any])
  public init(merchantConfig: Minerva.MerchantConfig, secretKey: Minerva.SecretKey, baseUrl: Swift.String, expirationTime: Swift.Int = Minerva.Config.expirationTime, firebaseConfig: Minerva.FirebaseConfig)
  @objc deinit
}
public class FirebaseConfig {
  public init(rawValue: [Swift.String : Any])
  public init(googleAppId: Swift.String, gcmSenderId: Swift.String, projectId: Swift.String, apiKey: Swift.String, databaseUrl: Swift.String, storageBucket: Swift.String)
  @objc deinit
}
public protocol Interceptor {
  associatedtype Input
  func intercept(chain: Minerva.InterceptorChain<Self.Input>, completion: @escaping (Self.Input) -> Swift.Void)
}
public class InterceptorChain<Input> {
  public convenience init()
  public init(interceptors: [Minerva.AnyInterceptor<Input>], input: Input? = nil)
  public var input: Input?
  @discardableResult
  public func add(interceptor: Minerva.AnyInterceptor<Input>) -> Minerva.InterceptorChain<Input>
  public func proceed(object: Input? = nil, completion: @escaping (Input) -> Swift.Void)
  @objc deinit
}
public struct AnyInterceptor<Input> : Minerva.Interceptor {
  public init<I>(base: I) where Input == I.Input, I : Minerva.Interceptor
  public func intercept(chain: Minerva.InterceptorChain<Input>, completion: @escaping (Input) -> Swift.Void)
}
public enum Currency {
  case vnd
  case loyalty
  public static func == (a: Minerva.Currency, b: Minerva.Currency) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol IPaymentResult {
  var isSuccess: Swift.Bool { get }
  var error: Minerva.PaymentError? { get }
}
public protocol AIOPaymentObservable {
  associatedtype PaymentResult : Minerva.IPaymentResult
  func observe(code: Swift.String, completion: @escaping (Self.PaymentResult) -> Swift.Void) throws
  func remove()
}
public protocol IAllowedPaymentMethod : Minerva.PaymentMethodHoldable {
  var displayName: Swift.String { get }
  var displayText: Swift.String { get }
  var displayIcon: Swift.String { get }
  var partnerCode: Swift.String { get }
}
extension PaymentV2 {
  public class AllowedPaymentMethod : Swift.Decodable, Minerva.IAllowedPaymentMethod {
    public var base: Minerva.IPaymentMethod
    public var displayName: Swift.String
    public var displayText: Swift.String
    public var displayIcon: Swift.String
    public var partnerCode: Swift.String
    required public init(from decoder: Swift.Decoder) throws
    @objc deinit
  }
}
extension PaymentV2 {
  public class MethodRegisterResult : Swift.Decodable {
    public var merchantCode: Swift.String
    public var methodCode: Swift.String
    public var terminalCode: Swift.String
    public var merchantMethodCode: Swift.String?
    public var errorCode: Swift.String?
    public var errorMessage: Swift.String?
    public init(merchantCode: Swift.String, methodCode: Swift.String, terminalCode: Swift.String, merchantMethodCode: Swift.String?, errorCode: Swift.String?, errorMessage: Swift.String?)
    required public init(from decoder: Swift.Decoder) throws
    @objc deinit
  }
}
extension PaymentV2.MethodRegisterResult : Minerva.IMethodRegisterResultInfo {
  public var isSuccess: Swift.Bool {
    get
  }
  public var terminal: Swift.String {
    get
  }
  public var error: Minerva.MethodRegisterError? {
    get
  }
  public var message: Swift.String? {
    get
  }
  public var type: Minerva.PaymentMethodType {
    get
  }
}
public enum PaymentObserveError : Swift.Error {
  case invalidRequestId
  case invalidObservePath
  case unexpected
  public static func == (a: Minerva.PaymentObserveError, b: Minerva.PaymentObserveError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class CodMethodRequest : Minerva.CorePaymentRequest {
  public typealias PaymentMethod = Minerva.CodMethod
  public typealias RequestExtraData = Minerva.BasicPaymentRequestExtraData
  public var method: Minerva.CodMethod
  public var amount: Minerva.IPaymentAmount
  public var extraData: Minerva.BasicPaymentRequestExtraData
  public var payload: [Swift.String : Any] {
    get
  }
  @objc deinit
}
extension CodMethodRequest {
  public convenience init(amount: Swift.Double)
}
@objc @_inheritsConvenienceInitializers public class QRScanViewController : Minerva.PaymentBaseViewController {
  @objc override dynamic public func viewDidLoad()
  @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @objc override dynamic public func viewWillDisappear(_ animated: Swift.Bool)
  @objc override dynamic public func viewDidLayoutSubviews()
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class VNPQrCodeMethod : Minerva.BasePaymentMethod {
  override public var type: Minerva.PaymentMethodType {
    get
  }
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class PaymentBaseViewController : UIKit.UIViewController {
  @objc override dynamic open func viewDidLoad()
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public typealias UserInfoResponseHandler = (Minerva.UserInfo?) -> Swift.Void
@_inheritsConvenienceInitializers public class OAuthService : TekCoreService.BasicWorkerService {
  public func getUserInfo(completion: @escaping Minerva.UserInfoResponseHandler)
  @objc deinit
  override public init(url: Foundation.URL, credential: TekCoreService.ServicesCredential? = super, errorDelegate: TekCoreService.ServicesErrorDelegate? = super)
}
public protocol ITransactionInitResult {
  var isSuccess: Swift.Bool { get }
  var error: Minerva.PaymentError? { get }
}
public typealias RegisterMerchantMethodsHandler = (Minerva.IMethodsRegisterResult) -> Swift.Void
public class BasicPaymentRequestExtraData : Minerva.IPaymentRequestExtraData {
  public var clientTransactionCode: Swift.String
  public init()
  @objc deinit
}
extension PaymentV2 {
  public enum AIOPaymentResult : Minerva.IPaymentResult {
    case success(transactionResult: Minerva.IObservedAIOTransaction)
    case failure(error: Minerva.PaymentError, transactionResult: Minerva.IObservedAIOTransaction?)
    public var isSuccess: Swift.Bool {
      get
    }
    public var error: Minerva.PaymentError? {
      get
    }
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class VNPSposMethod : Minerva.BasePaymentMethod {
  override public var type: Minerva.PaymentMethodType {
    get
  }
  @objc deinit
}
public struct PaymentTheme {
}
extension PaymentV2 {
  public struct RegisterMerchantMethodsResult : Minerva.IMethodsRegisterResult {
    public var message: Swift.String?
    public var error: Minerva.PaymentError?
    public var success: [Minerva.IMethodRegisterResultInfo] {
      get
    }
    public var failure: [Minerva.IMethodRegisterResultInfo] {
      get
    }
  }
}
public class PaymentV2 {
  public var config: Minerva.PaymentServiceConfig!
  public var appName: Swift.String
  public init(appName: Swift.String, config: Minerva.PaymentServiceConfig)
  @objc deinit
}
extension PaymentV2 : Minerva.IPaymentV2 {
  public func switchMerchantConfig(code: Swift.String, terminalCode: Swift.String)
  public func getAllowedPaymentMethods(payload: Minerva.PaymentV2.GetPaymentMethodsV3Payload, completion: @escaping (Swift.Result<Minerva.IGetPaymentMethodsResponse, Minerva.PaymentError>) -> Swift.Void)
  public func registerMethods(_ methods: [Minerva.PaymentMethodType], completion: @escaping Minerva.RegisterMerchantMethodsHandler)
  public func getQRReversalPaymentUI(order: Minerva.PaymentOrder, delegate: Minerva.PaymentUIDelegate) -> Minerva.PaymentViewController
  public func getPaymentUI(order: Minerva.PaymentOrder = PaymentOrder(orderCode: nil, amount: 0.0, userId: nil), delegate: Minerva.PaymentUIDelegate) -> Minerva.PaymentViewController
  public func initAIOTransaction(info: Minerva.PaymentV2.AIOPaymentInfo, requests: [Minerva.IPaymentRequest], completion: @escaping (Minerva.PaymentV2.AIOInitResult) -> Swift.Void)
  public func observePaymentResult(code: Swift.String, delegate: Minerva.PaymentObserverDelegate)
  public func cancelObservePaymentResult(code: Swift.String)
}
public protocol IDeposit {
  var allowDeposit: Swift.Bool { get }
  var payNowAmount: Swift.String? { get }
  var applyDepositIds: [Swift.Int]? { get }
}
extension PaymentV2 {
  public struct Deposit : Swift.Decodable, Minerva.IDeposit {
    public var allowDeposit: Swift.Bool
    public var payNowAmount: Swift.String?
    public var applyDepositIds: [Swift.Int]?
    public init(from decoder: Swift.Decoder) throws
  }
}
public protocol MethodRegisterError : Foundation.LocalizedError {
}
public enum CommonMethodRegisterError : Minerva.MethodRegisterError {
  case invalidMethod
  case other
  public static func == (a: Minerva.CommonMethodRegisterError, b: Minerva.CommonMethodRegisterError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public typealias UndefinedPaymentMethod = Minerva.BasePaymentMethod
@_hasMissingDesignatedInitializers public class BasePaymentMethod : Minerva.IPaymentMethod {
  public var groupType: Minerva.PaymentMethodGroupType
  public var type: Minerva.PaymentMethodType {
    get
  }
  public var merchantMethodCode: Swift.String
  @objc deinit
}
extension PaymentV2 {
  public enum VNPayMerchantMethodRegisterError : Minerva.MethodRegisterError {
    case inactiveTidMid
    case invalidData
    case invalidMethodCode
    case other
    public init(code: Swift.Int)
    public static func == (a: Minerva.PaymentV2.VNPayMerchantMethodRegisterError, b: Minerva.PaymentV2.VNPayMerchantMethodRegisterError) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
public protocol IAIOInitResponse {
  var message: Swift.String? { get }
  var orderCode: Swift.String? { get }
  var payments: Minerva.IInitialTransactionsList? { get }
  var paymentRequestId: Swift.String { get }
}
extension PaymentV2 {
  @_hasMissingDesignatedInitializers public class AIOInitResponse : TekCoreNetwork.BaseResponse<Minerva.PaymentV2.PaymentCode> {
    @objc deinit
    override public init(code: Minerva.PaymentV2.PaymentCode)
  }
}
extension PaymentV2.AIOInitResponse : Minerva.IAIOInitResponse {
  public var orderCode: Swift.String? {
    get
  }
  public var message: Swift.String? {
    get
  }
  public var payments: Minerva.IInitialTransactionsList? {
    get
  }
  public var paymentRequestId: Swift.String {
    get
  }
}
public protocol IPaymentRequestExtraData {
  var clientTransactionCode: Swift.String { get }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class LoyaltyMethod : Minerva.BasePaymentMethod {
  override public var type: Minerva.PaymentMethodType {
    get
  }
  @objc deinit
}
extension PaymentV2 {
  public class PaymentCode : TekCoreNetwork.TekoCodeProtocol, Swift.Decodable {
    public var successCode: Swift.String
    public var code: Swift.String?
    public var error: Swift.Error?
    public var message: Swift.String?
    public var details: [Minerva.PaymentV2.PaymentDetailError]?
    required public init(from decoder: Swift.Decoder) throws
    @objc deinit
    public typealias ValueType = Swift.String
  }
  @_hasMissingDesignatedInitializers public class PaymentDetailError : Swift.Decodable {
    @objc deinit
    required public init(from decoder: Swift.Decoder) throws
  }
  @_hasMissingDesignatedInitializers public class PaymentErrorMetaData : Swift.Decodable {
    @objc deinit
    required public init(from decoder: Swift.Decoder) throws
  }
}
public protocol IPaymentAmount {
  var currency: Minerva.Currency { get }
  var amount: Swift.Double { get }
  var realAmount: Swift.Double { get }
}
public struct PaymentAmount : Minerva.IPaymentAmount {
  public var currency: Minerva.Currency
  public var amount: Swift.Double
  public var realAmount: Swift.Double
  public init(currency: Minerva.Currency, amount: Swift.Double, conversationRate: Swift.Double? = nil)
}
public class Minerva {
  public static var configName: Swift.String
  public var config: Minerva.PaymentServiceConfig!
  public var appName: Swift.String
  public init(appName: Swift.String, config: Minerva.PaymentServiceConfig)
  @objc deinit
}
extension Minerva {
  public static func configure(app: TerraInstancesManager.ITerraApp) -> Minerva.Minerva
}
public enum PaymentMethodGroupType : Swift.String {
  case card
  case credit
  case loyalty
  case qr
  case undefined
  public init(methodCode: Swift.String)
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
extension PaymentV2 {
  public enum AIOInitResult {
    case success(response: Minerva.IAIOInitResponse)
    case failure(error: Minerva.PaymentError, response: Minerva.IAIOInitResponse?)
  }
}
extension PaymentV2.AIOInitResult : Minerva.ITransactionInitResult {
  public var isSuccess: Swift.Bool {
    get
  }
  public var error: Minerva.PaymentError? {
    get
  }
}
public protocol IInitialTransaction : AnyObject {
  var clientTransactionCode: Swift.String { get }
  var transactionCode: Swift.String { get }
  var methodCode: Swift.String { get }
  var responseCode: Swift.String? { get }
  var responseMessage: Swift.String? { get }
  var qrContent: Swift.String? { get }
  var returnUrl: Swift.String? { get }
  var traceId: Swift.String { get }
  var merchantMethodCode: Swift.String { get set }
  var amount: Swift.Int { get }
  var paymentRequestId: Swift.String { get set }
  var methodType: Minerva.PaymentMethodType { get }
  var error: Minerva.PaymentError.ServiceError? { get }
  var partnerError: Swift.Error? { get }
}
extension PaymentV2 {
  public class InitialTransaction : Swift.Decodable, Minerva.IInitialTransaction {
    public var clientTransactionCode: Swift.String
    public var transactionCode: Swift.String
    public var methodCode: Swift.String
    public var responseCode: Swift.String?
    public var responseMessage: Swift.String?
    public var qrContent: Swift.String?
    public var returnUrl: Swift.String?
    public var traceId: Swift.String
    public var merchantMethodCode: Swift.String
    public var merchantCode: Swift.String
    public var amount: Swift.Int
    public var paymentRequestId: Swift.String
    public var partnerResponseCode: Swift.String
    required public init(from decoder: Swift.Decoder) throws
    public var isSuccess: Swift.Bool {
      get
    }
    public var methodType: Minerva.PaymentMethodType {
      get
    }
    public var error: Minerva.PaymentError.ServiceError? {
      get
    }
    public var partnerError: Swift.Error? {
      get
    }
    @objc deinit
  }
}
extension PaymentV2 {
  @_hasMissingDesignatedInitializers public class PaymentObserver {
    public typealias PaymentResult = Minerva.PaymentV2.AIOPaymentResult
    public func observe(code: Swift.String, completion: @escaping (Minerva.PaymentV2.AIOPaymentResult) -> Swift.Void) throws
    public func remove()
    @objc deinit
  }
}
public enum VNPGatewaySubMethod {
  case qr
  case atm
  case visa
  case mobileBanking
  public static func == (a: Minerva.VNPGatewaySubMethod, b: Minerva.VNPGatewaySubMethod) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class VNPGatewayMethod : Minerva.IPaymentMethod {
  public var type: Minerva.PaymentMethodType
  public var groupType: Minerva.PaymentMethodGroupType
  public var merchantMethodCode: Swift.String
  public var subMethod: Minerva.VNPGatewaySubMethod
  @objc deinit
}
public typealias IMinerva = Minerva.IPaymentV2
public typealias GetPaymentMethodsPayload = Minerva.PaymentV2.GetPaymentMethodsV3Payload
public typealias AIOInitResult = Minerva.PaymentV2.AIOInitResult
public typealias GetPaymentMethodsResponse = Minerva.PaymentV2.GetPaymentMethodsResponse
public typealias AIOPaymentInfo = Minerva.PaymentV2.AIOPaymentInfo
public typealias AIOPaymentResult = Minerva.PaymentV2.AIOPaymentResult
public typealias PaymentObserverDelegate = Minerva.PaymentV2ObserverDelegate
public typealias PaymentResultObservable = Minerva.PaymentV2ResultObservable
extension Minerva : Minerva.IMinerva {
  public func switchMerchantConfig(code: Swift.String, terminalCode: Swift.String)
  public func getAllowedPaymentMethods(payload: Minerva.GetPaymentMethodsPayload, completion: @escaping (Swift.Result<Minerva.IGetPaymentMethodsResponse, Minerva.PaymentError>) -> Swift.Void)
  public func registerMethods(_ methods: [Minerva.PaymentMethodType], completion: @escaping Minerva.RegisterMerchantMethodsHandler)
  public func getQRReversalPaymentUI(order: Minerva.PaymentOrder, delegate: Minerva.PaymentUIDelegate) -> Minerva.PaymentViewController
  public func getPaymentUI(order: Minerva.PaymentOrder = PaymentOrder(orderCode: nil, amount: 0.0, userId: nil), delegate: Minerva.PaymentUIDelegate) -> Minerva.PaymentViewController
  public func initAIOTransaction(info: Minerva.AIOPaymentInfo, requests: [Minerva.IPaymentRequest], completion: @escaping (Minerva.AIOInitResult) -> Swift.Void)
  public func observePaymentResult(code: Swift.String, delegate: Minerva.PaymentObserverDelegate)
  public func cancelObservePaymentResult(code: Swift.String)
}
@_hasMissingDesignatedInitializers public class GatewayRequestExtraData : Minerva.BasicPaymentRequestExtraData {
  @objc deinit
  override public init()
}
@_hasMissingDesignatedInitializers public class QrCodeRequestExtraData : Minerva.BasicPaymentRequestExtraData {
  public enum QrImageType : Swift.Int {
    case normal
    case binary
    case urlImage
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public struct QrSize {
    public init(width: Swift.Int?, height: Swift.Int?)
  }
  @objc deinit
  override public init()
}
public protocol IPaymentRequestInfo : Minerva.UserIdHoldable {
  var orderCode: Swift.String { get }
  override var userId: Swift.String { get set }
  var totalPaymentAmount: Swift.Int { get }
}
@_inheritsConvenienceInitializers public class OAuthConfigConverter : TekCoreService.BaseServiceConverter<Minerva.OAuthConfig> {
  override public func convertConfig(rawValue: [Swift.String : Any]) -> Minerva.OAuthConfig
  @objc deinit
  required public init(input: [Swift.String : Any])
}
public protocol PaymentUIDelegate : AnyObject {
  func onResult(_ result: Minerva.AIOPaymentResult)
  func onCancel()
}
public enum ObserveResult {
  case success
  case failure(Minerva.PaymentObserveError)
}
public protocol ObserverDelegate : AnyObject {
  func onObserveResult(code: Swift.String, result: Minerva.ObserveResult)
}
extension ObserverDelegate {
  public func onObserveResult(code: Swift.String, result: Minerva.ObserveResult)
}
@objc @_inheritsConvenienceInitializers public class PaymentViewController : Minerva.PaymentBaseViewController {
  @objc override dynamic public func viewDidLoad()
  @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@_hasMissingDesignatedInitializers public class QrReversalMethodRequest : Minerva.CorePaymentRequest {
  public typealias PaymentMethod = Minerva.VNPQrReversalMethod
  public typealias RequestExtraData = Minerva.QrReversalRequestExtraData
  public var method: Minerva.VNPQrReversalMethod
  public var amount: Minerva.IPaymentAmount
  public var extraData: Minerva.QrReversalRequestExtraData
  public var payload: [Swift.String : Any] {
    get
  }
  @objc deinit
}
extension QrReversalMethodRequest {
  public convenience init(amount: Swift.Double, customerPhone: Swift.String, qrContent: Swift.String)
}
@_hasMissingDesignatedInitializers public class SposMethodRequest : Minerva.CorePaymentRequest {
  public typealias PaymentMethod = Minerva.VNPSposMethod
  public typealias RequestExtraData = Minerva.BasicPaymentRequestExtraData
  public var method: Minerva.VNPSposMethod
  public var amount: Minerva.IPaymentAmount
  public var extraData: Minerva.BasicPaymentRequestExtraData
  public var payload: [Swift.String : Any] {
    get
  }
  @objc deinit
}
extension SposMethodRequest {
  public convenience init(amount: Swift.Double)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class CodMethod : Minerva.BasePaymentMethod {
  override public var type: Minerva.PaymentMethodType {
    get
  }
  @objc deinit
}
public protocol IInitialTransactionsList {
  var credit: Minerva.IInitialTransaction? { get }
  var loyalty: Minerva.IInitialTransaction? { get }
  var qr: Minerva.IInitialTransaction? { get }
  var card: Minerva.IInitialTransaction? { get }
}
extension PaymentV2 {
  public class InitialTransactionsList : Swift.Decodable {
    required public init(from decoder: Swift.Decoder) throws
    @objc deinit
  }
}
extension PaymentV2.InitialTransactionsList : Minerva.IInitialTransactionsList {
  public var credit: Minerva.IInitialTransaction? {
    get
  }
  public var loyalty: Minerva.IInitialTransaction? {
    get
  }
  public var qr: Minerva.IInitialTransaction? {
    get
  }
  public var card: Minerva.IInitialTransaction? {
    get
  }
}
@_hasMissingDesignatedInitializers public class ImagesHelper {
  public static func imageFor(name imageName: Swift.String) -> UIKit.UIImage?
  public static func assestFor(name imageName: Swift.String) -> UIKit.UIImage?
  @objc deinit
}
extension UIImage {
  public convenience init?(color: UIKit.UIColor, size: CoreGraphics.CGSize = CGSize(width: 1, height: 1))
}
@_hasMissingDesignatedInitializers public class QrReversalRequestExtraData : Minerva.BasicPaymentRequestExtraData {
  @objc deinit
  override public init()
}
public protocol IObservedAIOTransaction {
  var requestId: Swift.String { get }
  var amount: Swift.Double { get }
  var status: Swift.String { get }
  var message: Swift.String { get }
  var createdTime: Swift.Int { get }
  var terminalCode: Swift.String { get }
  var merchantCode: Swift.String { get }
  var orderCode: Swift.String { get }
  var transactions: [Minerva.IObservedTransaction] { get }
  var error: Minerva.PaymentError? { get }
}
extension PaymentV2 {
  public struct ObservedAIOTransaction : Minerva.IObservedAIOTransaction {
    public var requestId: Swift.String
    public var amount: Swift.Double
    public var status: Swift.String
    public var message: Swift.String
    public var createdTime: Swift.Int
    public var terminalCode: Swift.String
    public var merchantCode: Swift.String
    public var orderCode: Swift.String
    public var transactions: [Minerva.IObservedTransaction]
    public var isSuccess: Swift.Bool {
      get
    }
    public init(fromDict dict: [Swift.String : Any])
    public var error: Minerva.PaymentError? {
      get
    }
  }
}
@_hasMissingDesignatedInitializers public class GatewayMethodRequest : Minerva.CorePaymentRequest {
  public typealias PaymentMethod = Minerva.VNPGatewayMethod
  public typealias RequestExtraData = Minerva.GatewayRequestExtraData
  public var method: Minerva.VNPGatewayMethod
  public var amount: Minerva.IPaymentAmount
  public var extraData: Minerva.GatewayRequestExtraData
  public var payload: [Swift.String : Any] {
    get
  }
  @objc deinit
}
extension GatewayMethodRequest {
  public convenience init(subMethod: Minerva.VNPGatewaySubMethod, amount: Swift.Double, bankCode: Swift.String? = nil)
}
extension Encodable {
  public var dictionary: [Swift.String : Any] {
    get
  }
  public func stringify(withChecksum: Swift.Bool = false) -> Swift.String
}
public typealias MinervaConfig = Minerva.PaymentServiceConfig
public class MinervaGenerator : TerraInstancesManager.InstanceGeneratable {
  public typealias InstanceType = Minerva.Minerva
  required public init()
  public func generateInstance(app: TerraInstancesManager.ITerraApp) -> Minerva.Minerva?
  public func generateDefaultInstance(config: Minerva.MinervaConfig) -> Minerva.Minerva
  public func generateDefaultInstance(config: [Swift.String : Any]) -> Minerva.Minerva
  @objc deinit
}
@_hasMissingDesignatedInitializers public class MinervaSingleton : TerraInstancesManager.InstancesManageable {
  public typealias Generator = Minerva.MinervaGenerator
  public static var shared: Minerva.MinervaSingleton
  public var instances: [Swift.String : Minerva.Minerva]
  public static var DEFAULT_VALUE: Swift.String
  public var `default`: Minerva.Minerva {
    get
  }
  public func configureWith(config: Minerva.MinervaConfig)
  public func configureWith(config: [Swift.String : Any])
  public func configureWith(app: TerraInstancesManager.ITerraApp)
  @objc deinit
}
public var TerraPayment: Minerva.MinervaSingleton
extension PaymentV2 {
  public enum LoyaltyError : Minerva.PartnerError {
    case notEnoughBalance
    case other
    public init(code: Swift.String)
    public static func == (a: Minerva.PaymentV2.LoyaltyError, b: Minerva.PaymentV2.LoyaltyError) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
public protocol IPaymentOrder : AnyObject {
  var amount: Swift.Double { get set }
  var orderCode: Swift.String? { get set }
  var userId: Swift.String? { get set }
}
public class PaymentOrder : Minerva.IPaymentOrder {
  public var amount: Swift.Double
  public var orderCode: Swift.String?
  public var userId: Swift.String?
  public var note: Swift.String?
  public init(orderCode: Swift.String?, amount: Swift.Double, userId: Swift.String?, note: Swift.String? = nil)
  @objc deinit
}
public protocol IPaymentRequest : AnyObject {
  var methodType: Minerva.PaymentMethodType { get }
  var methodGroupType: Minerva.PaymentMethodGroupType { get set }
  var checksumString: Swift.String { get }
  var payload: [Swift.String : Any] { get }
  var merchantMethodCode: Swift.String { get set }
}
public protocol CorePaymentRequest : Minerva.IPaymentRequest {
  associatedtype PaymentMethod : Minerva.IPaymentMethod
  associatedtype RequestExtraData : Minerva.IPaymentRequestExtraData
  var method: Self.PaymentMethod { get set }
  var amount: Minerva.IPaymentAmount { get }
  var extraData: Self.RequestExtraData { get }
  override var checksumString: Swift.String { get }
}
extension CorePaymentRequest {
  public var checksumString: Swift.String {
    get
  }
  public var methodType: Minerva.PaymentMethodType {
    get
  }
  public var merchantMethodCode: Swift.String {
    get
    set(newValue)
  }
  public var methodGroupType: Minerva.PaymentMethodGroupType {
    get
    set(newValue)
  }
}
extension PaymentV2 {
  @_hasMissingDesignatedInitializers public class GetPaymentMethodsV2Payload : Swift.Encodable {
    public var userId: Swift.String
    public var terminalCode: Swift.String
    public var amount: Swift.Int
    public convenience init(userId: Swift.String? = nil, amount: Swift.Int)
    @objc deinit
    public func encode(to encoder: Swift.Encoder) throws
  }
}
@objc @_inheritsConvenienceInitializers @available(tvOS, unavailable)
public class KeyboardLayoutConstraint : UIKit.NSLayoutConstraint {
  @available(tvOS, unavailable)
  @objc override dynamic public func awakeFromNib()
  @objc deinit
  @objc override dynamic public init()
}
public struct OAuthConfig {
  public var url: Swift.String
}
extension Minerva {
  public struct Config {
    public static var expirationTime: Swift.Int
  }
  public struct NavigationBar {
    public enum Theme {
      case white
      case primary
      public static func == (a: Minerva.Minerva.NavigationBar.Theme, b: Minerva.Minerva.NavigationBar.Theme) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public static var height: CoreGraphics.CGFloat
  }
  public struct Images {
    public static var backButton: UIKit.UIImage?
    public static var backWhiteButton: UIKit.UIImage?
    public static var sposIcon: UIKit.UIImage?
    public static var qrIcon: UIKit.UIImage?
    public static var cardIcon: UIKit.UIImage?
  }
}
public protocol UserIdHoldable : AnyObject {
  var userId: Swift.String { get set }
}
@_hasMissingDesignatedInitializers public class DateUtils {
  public static func toString(date: Foundation.Date) -> Swift.String
  @objc deinit
}
public protocol IPaymentMethod {
  var type: Minerva.PaymentMethodType { get }
  var groupType: Minerva.PaymentMethodGroupType { get set }
  var merchantMethodCode: Swift.String { get set }
  var methodCode: Swift.String { get }
}
extension IPaymentMethod {
  public var methodCode: Swift.String {
    get
  }
}
extension Minerva {
  public enum MiniAppEvent {
    case startPayment
    public var name: Swift.String {
      get
    }
    public static func == (a: Minerva.Minerva.MiniAppEvent, b: Minerva.Minerva.MiniAppEvent) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
public enum PaymentMethodType {
  case vnPayGateway(sub: Minerva.VNPGatewaySubMethod)
  case vnPayQrCode
  case vnPaySpos
  case vnPayToken
  case vnPayEWallet
  case vnPayQrReversal
  case alePayCredit
  case loyalty
  case cod
  case undefined
}
extension PaymentMethodType : Swift.Equatable {
}
public func == (lhs: Minerva.PaymentMethodType, rhs: Minerva.PaymentMethodType) -> Swift.Bool
@_hasMissingDesignatedInitializers public class CrypUtils {
  public static func md5(text: Swift.String, secretKey: Swift.String) -> Swift.String
  public static func sha256(text: Swift.String) -> Swift.String
  @objc deinit
}
public protocol PaymentV2ObserverDelegate : Minerva.ObserverDelegate {
  func onPaymentResult(_ result: Minerva.AIOPaymentResult)
}
public protocol PaymentV2ResultObservable {
  func observePaymentResult(code: Swift.String, delegate: Minerva.PaymentV2ObserverDelegate)
  func cancelObservePaymentResult(code: Swift.String)
}
public protocol IPaymentV2 : Minerva.PaymentV2ResultObservable {
  func switchMerchantConfig(code: Swift.String, terminalCode: Swift.String)
  func getAllowedPaymentMethods(payload: Minerva.PaymentV2.GetPaymentMethodsV3Payload, completion: @escaping (Swift.Result<Minerva.IGetPaymentMethodsResponse, Minerva.PaymentError>) -> Swift.Void)
  func registerMethods(_ methods: [Minerva.PaymentMethodType], completion: @escaping Minerva.RegisterMerchantMethodsHandler)
  func initAIOTransaction(info: Minerva.AIOPaymentInfo, requests: [Minerva.IPaymentRequest], completion: @escaping (Minerva.PaymentV2.AIOInitResult) -> Swift.Void)
  func getPaymentUI(order: Minerva.PaymentOrder, delegate: Minerva.PaymentUIDelegate) -> Minerva.PaymentViewController
  func getQRReversalPaymentUI(order: Minerva.PaymentOrder, delegate: Minerva.PaymentUIDelegate) -> Minerva.PaymentViewController
}
public class UserInfo : Swift.Decodable {
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
}
public protocol PartnerError : Foundation.LocalizedError {
}
public protocol PaymentMethodHoldable {
  var base: Minerva.IPaymentMethod { get }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class VNPQrReversalMethod : Minerva.BasePaymentMethod {
  override public var type: Minerva.PaymentMethodType {
    get
  }
  @objc deinit
}
public class OAuthServiceInstanceGenerator : TerraInstancesManager.ServiceInstanceGeneratable {
  public typealias InstanceType = Minerva.OAuthService
  public typealias ServiceFactory = Minerva.OAuthServiceFactory
  required public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class TerraOAuthSingleton : TerraInstancesManager.InstancesManageable {
  public typealias Generator = Minerva.OAuthServiceInstanceGenerator
  public static var shared: Minerva.TerraOAuthSingleton
  public var instances: [Swift.String : Minerva.OAuthService]
  @objc deinit
}
public var TerraOAuth: Minerva.TerraOAuthSingleton
public protocol IGetPaymentMethodsResponse {
  var merchantCode: Swift.String { get }
  var allowedPaymentMethods: [Minerva.IAllowedPaymentMethod] { get }
  var deposit: Minerva.IDeposit? { get }
  var message: Swift.String? { get }
}
extension PaymentV2 {
  public class GetPaymentMethodsResponse : TekCoreNetwork.BaseResponse<Minerva.PaymentV2.PaymentCode> {
    public var merchantCode: Swift.String
    public var _deposit: Minerva.PaymentV2.Deposit?
    public var message: Swift.String? {
      get
    }
    required public init(from decoder: Swift.Decoder) throws
    @objc deinit
    override public init(code: Minerva.PaymentV2.PaymentCode)
  }
}
extension PaymentV2.GetPaymentMethodsResponse : Minerva.IGetPaymentMethodsResponse {
  public var allowedPaymentMethods: [Minerva.IAllowedPaymentMethod] {
    get
  }
  public var deposit: Minerva.IDeposit? {
    get
  }
}
extension PaymentV2 {
  @_hasMissingDesignatedInitializers public class GetPaymentMethodsV3Payload : Minerva.PaymentV2.GetPaymentMethodsV2Payload {
    public var merchantCode: Swift.String
    public convenience init(userId: Swift.String? = nil, amount: Swift.Int)
    override public func encode(to encoder: Swift.Encoder) throws
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers public class LoyaltyMethodRequest : Minerva.CorePaymentRequest {
  public typealias PaymentMethod = Minerva.LoyaltyMethod
  public typealias RequestExtraData = Minerva.BasicPaymentRequestExtraData
  public var method: Minerva.LoyaltyMethod
  public var amount: Minerva.IPaymentAmount
  public var extraData: Minerva.BasicPaymentRequestExtraData
  public var payload: [Swift.String : Any] {
    get
  }
  @objc deinit
}
extension LoyaltyMethodRequest {
  public convenience init(points: Swift.Int, conversationRate: Swift.Double)
}
extension UIColor {
  public convenience init(hex3: Swift.UInt16, alpha: CoreGraphics.CGFloat = 1)
}
public protocol IObservedTransaction {
  var methodType: Minerva.PaymentMethodType { get }
  var amount: Swift.Double { get }
  var message: Swift.String { get }
  var ref: Swift.String { get }
  var status: Swift.String { get }
  var transactionCode: Swift.String { get }
  var merchantCode: Swift.String { get }
  var merchantMethodCode: Swift.String { get }
  var methodCode: Swift.String { get }
  var partnerStatus: Swift.String { get }
  var error: Minerva.PaymentError.ServiceError? { get }
  var partnerError: Swift.Error? { get }
}
extension PaymentV2 {
  public class ObservedTransaction : Minerva.IObservedTransaction {
    public var amount: Swift.Double
    public var message: Swift.String
    public var ref: Swift.String
    public var status: Swift.String
    public var transactionCode: Swift.String
    public var partnerStatus: Swift.String
    public var merchantCode: Swift.String
    public var methodCode: Swift.String
    public var merchantMethodCode: Swift.String
    public var isSuccess: Swift.Bool {
      get
    }
    public init(fromDict dict: [Swift.String : Any])
    public var methodType: Minerva.PaymentMethodType {
      get
    }
    public var error: Minerva.PaymentError.ServiceError? {
      get
    }
    public var partnerError: Swift.Error? {
      get
    }
    @objc deinit
  }
}
extension PaymentV2 {
  public class AIOPaymentInfo : Minerva.IPaymentRequestInfo {
    public var orderCode: Swift.String
    public var userId: Swift.String
    public var totalPaymentAmount: Swift.Int
    public var expiredDate: Foundation.Date?
    public var successUrl: Swift.String
    public var cancelUrl: Swift.String
    public init(userId: Swift.String? = nil, orderCode: Swift.String, totalPaymentAmount: Swift.Int, expiredDate: Foundation.Date? = nil, successUrl: Swift.String = "https://payment.teko.vn", cancelUrl: Swift.String = "https://payment.teko.vn")
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers public class QrCodeMethodRequest : Minerva.CorePaymentRequest {
  public typealias PaymentMethod = Minerva.VNPQrCodeMethod
  public typealias RequestExtraData = Minerva.QrCodeRequestExtraData
  public var method: Minerva.VNPQrCodeMethod
  public var amount: Minerva.IPaymentAmount
  public var extraData: Minerva.QrCodeRequestExtraData
  public var payload: [Swift.String : Any] {
    get
  }
  @objc deinit
}
extension QrCodeMethodRequest {
  public convenience init(amount: Swift.Double, qrType: Minerva.QrCodeRequestExtraData.QrImageType = .normal, qrSize: Minerva.QrCodeRequestExtraData.QrSize? = nil)
}
public class OAuthServiceFactory : TekCoreService.ServiceBuildable, TekCoreService.ServiceConverterSupportable, TekCoreService.ServiceCredentialAttachable {
  public typealias ServiceConverter = Minerva.OAuthConfigConverter
  public var credential: TekCoreService.ServicesCredential?
  public var rawConfig: [Swift.String : Any]
  public var serviceName: Swift.String
  weak public var errorDelegate: TekCoreService.ServicesErrorDelegate?
  required public init()
  public func createService() throws -> TekCoreService.CoreService
  public func withCredential(_ credential: TekCoreService.ServicesCredential)
  @objc deinit
}
extension Minerva.PaymentV2.PaymentObserver : Minerva.AIOPaymentObservable {}
extension Minerva.PaymentV2.GetPaymentMethodsV2Payload : Minerva.UserIdHoldable {}
extension Minerva.PaymentV2.GetPaymentMethodsV3Payload : Minerva.UserIdHoldable {}
